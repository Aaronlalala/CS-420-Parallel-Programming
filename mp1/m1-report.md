# Part A

## Question 1

Posix_memalign is a function in the POSIX standard library that is used to align the memory to ensure that data is stored in a way that corresponds to the cache's line size. If the data is not aligned, it may span multiple cache lines, resulting in more cache misses and slower performance.

## Question 2

In naive matrix multiplication, its for loop for row cannot well utilize cache. When the dimension of the matrix is large, cache cannot store all elements in one row. Then, it keeps generating cache misses when computing the inner product between row and column. This is becuase after it iterates to the end of a row, the values previously fetched has been removed.

In addition, for each row, it computes the inner product with each columns. However, after computing inner product of row i with all columns, it needs to fetch all column valus from the main memory again when computing the inner product with row i+1.

Starting from matrix with size 256, the results show many noticeable differences. And this difference increases when size of matrix gets larger.

## Question 3

When tile size is small, the megaflops are small and increases as tile size increases. When tile size is large, the megaflops are also small and decreases as tile size increases. The optimal tile size is 16. Details could see the following results:

<img src="/Users/aaronlalala/Documents/Courses/UIUC/CS 420/mp1/result-screenshot.png" alt="image-20230220234422955" style="zoom:50%;" />

## Question 4

Yes it somehow changes the performance. But the differences are not significantly large.

Metric: MegaFlops/s.

### Row-Column Order

16*16: 592.40

32*32: 268.43

512*512: 264.87

1024*1024: 316.66

2048*2048: 93.95 

### Column-Row Order

16*16: 241.97

32*32: 289.95

512*512: 284.29

1024*1024: 309.01

2048*2048: 86.34



Except when matrix is 16*16, row column-order is significantly faster than column-row order, in other small matrix multiplication, column-row order is slightly faster than row-column order.

However, as dimension of matrix is large, row column-order is consistently faster than column-row order.

I think this might due to spatial locality. When matrix dimension is small a cache line could store entire row and thus, fix column at outer loop is more efficient than fix row at outer loop. However, when dimension of matrix is large this advantage diminishes, because it cannot store the entire row in a cache block.

# Part B

![result](/Users/aaronlalala/Documents/Courses/UIUC/CS 420/mp1/result.png)

The above subplots are generated by seaborn.catplot function, which compare the MFLOP for different variants and tile number with the matrix size.
